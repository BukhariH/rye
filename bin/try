#!/usr/bin/ruby

$:.unshift File.join(File.dirname(__FILE__), '..', 'lib')


require 'rubygems'
require 'stringio'
require 'yaml'
require 'rye'

# ------------------------------------------------------------------
#   EXAMPLE 1 -- Basic Usage
#

rbox = Rye::Box.new('localhost')

# Commands are run as methods on the Rye::Box object

puts rbox.uptime                # => 11:02  up 16:01, 3 users


# The response value for all commands is a Rye::Rap object. The rap is a
# subclass of Array so you can treat it as an Array, but it can also act 
# like a String if there's only one element. It also keeps a reference to the 
# object that called the command. In this case, it will keep a reference

puts rbox.ls('rye.test')        # => ls: rye.test: No such file or directory
puts rbox.touch('rye.test')     # => nil
puts rbox.rm('rye.test')        # => nil

puts rbox.echo('$HOME')         # => $HOME

puts rbox.pwd                   # => /home/rye
puts rbox['/usr/bin'].pwd       # => /usr/bin
puts rbox.pwd                   # => /usr/bin
puts rbox.cd('/home/rye').pwd   # => /home/rye

puts rbox.commands.join(', ')   # => pwd, touch, echo, wc, ...

rbox.disconnect


# ------------------------------------------------------------------
#   EXAMPLE 2 -- Custom Commands
#

rbox = Rye::Box.new('localhost')
rbox.add_keys('/private/key/path')  # Specify additional private keys

begin
  puts rbox.git('--help')  
  
rescue NoMethodError => ex
  puts ex.message                   # => undefined method `git' for #<Rye::Box ...>
end

module Rye::Cmd
  def git(*args); cmd("git", args);  end
end

puts rbox.git('--help')             # => usage: git [--version] ...
puts rbox.commands.member?('git')   # => true


# ------------------------------------------------------------------
#   EXAMPLE 3 -- Accessing Multiple Machines
#

rset = Rye::Set.new
rbox = Rye::Box.new

rset.add_keys('/private/key/path')       # For passwordless logins 
rset.add_boxes(rbox, 'localhost')        # Add boxes as hostnames or objects

# Calling methods on Rye::Set objects is very similar to calling them on
# Rye::Box objects. In fact, it's identical:

p rset.uptime        # => [[14:19:02 up 32 days, 19:35 ...], [14:19:02 up 30 days, 01:35]]
p rset['/etc'].ls    # => [['file1', 'file2', ...], ['life1', 'life2', ...]]

# And like Rye::Box, the response value is a Rye::Rap object containing 
# the responses from each box. Each response is itself a Rye::Rap object.

unames = rset.uname
p unames                             # => [["Darwin"], ["Darwin"]]
puts unames.class                    # => Rye::Rap
puts unames.set                      # => Rye::Set
puts unames.set == rset              # => true
puts unames.size                     # => 2
puts unames.first                    # => Darwin
puts unames.first.class              # => Rye::Rap
puts unames.first.box                # => Rye::Box
puts unames.first.box == rbox        # => true

# Envrionment variables can be set the same way as with Rye::Box
rset.add_env(:RYE, "Forty Creek")
p rset.env.first.select { |env| env =~ /RYE/ }  # => ["RYE=Forty Creek"]



